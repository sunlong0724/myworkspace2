/* -LICENSE-START-
 ** Copyright (c) 2014 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#include "platform.h"
#include "DeckLinkInputDevice.h"
#include "FPSCounter.h"

// The input callback class
class NotificationCallback : public IDeckLinkInputCallback
{
    
public:
    IDeckLinkInput*				m_deckLinkInput;

	SinkDataCallback			m_cb;
	void*						m_cb_ctx;

	PixelFormatChangedCallback	m_pixle_format_changed_cb;
	void*						m_pixle_format_changed_cb_ctx;

	CFPSCounter					m_grab_fps;

    
    NotificationCallback(IDeckLinkInput *deckLinkInput)
    {
        m_deckLinkInput = deckLinkInput;
    }
    
    ~NotificationCallback(void)
    {
        
    }
	
	HRESULT		STDMETHODCALLTYPE QueryInterface (REFIID iid, LPVOID *ppv)
	{
        return E_NOINTERFACE;
    }
	
    ULONG		STDMETHODCALLTYPE AddRef ()
    {
        return 1;
    }
	
    ULONG		STDMETHODCALLTYPE Release ()
    {
        return 1;
    }
    
    // The callback that is called when a property of the video input stream has changed.
	HRESULT		STDMETHODCALLTYPE VideoInputFormatChanged (/* in */ BMDVideoInputFormatChangedEvents notificationEvents, /* in */ IDeckLinkDisplayMode *newDisplayMode, /* in */ BMDDetectedVideoInputFormatFlags detectedSignalFlags)
    {
        BMDPixelFormat pixelFormat = bmdFormat10BitYUV;
        STRINGOBJ			displayModeString = NULL;
        
        // Check for video field changes
        if (notificationEvents & bmdVideoInputFieldDominanceChanged)
        {
            BMDFieldDominance fieldDominance;
            
            fieldDominance = newDisplayMode->GetFieldDominance();
            printf("Input field dominance changed to ");
            switch (fieldDominance) {
                case bmdUnknownFieldDominance:
                    printf("unknown\n");
                    break;
                case bmdLowerFieldFirst:
                    printf("lower field first\n");
                    break;
                case bmdUpperFieldFirst:
                    printf("upper field first\n");
                    break;
                case bmdProgressiveFrame:
                    printf("progressive\n");
                    break;
                case bmdProgressiveSegmentedFrame:
                    printf("progressive segmented frame\n");
                    break;
                default:
                    break;
            }
        }
        
		int pixel = 0;
		std::string modeName;

        // Check if the pixel format has changed
        if (notificationEvents & bmdVideoInputColorspaceChanged)
        {
            printf("Input color space changed to ");
            if (detectedSignalFlags == bmdDetectedVideoInputYCbCr422)
            {
                printf("YCbCr422\n");
                pixelFormat = bmdFormat10BitYUV;
				pixel = 1;

            }
            if (detectedSignalFlags == bmdDetectedVideoInputRGB444)
            {
                printf("RGB444\n");
                pixelFormat = bmdFormat10BitRGB;
				pixel = 2;
            }
        }

        // Check if the video mode has changed
        if (notificationEvents & bmdVideoInputDisplayModeChanged)
        {
            // Obtain the name of the video mode 
            newDisplayMode->GetName(&displayModeString);
            StringToStdString(displayModeString, modeName);
            
            printf("Input display mode changed to: %s\n", modeName.c_str());
            // Release the video mode name string
            STRINGFREE(displayModeString);
        }

		if (m_pixle_format_changed_cb) {
			m_pixle_format_changed_cb(pixel, (char*)modeName.data(), m_pixle_format_changed_cb_ctx);
		}
        
        // Pause video capture
        m_deckLinkInput->PauseStreams();
        
        // Enable video input with the properties of the new video stream
        m_deckLinkInput->EnableVideoInput(newDisplayMode->GetDisplayMode(), pixelFormat, bmdVideoInputEnableFormatDetection);

        // Flush any queued video frames
        m_deckLinkInput->FlushStreams();

        // Start video capture
        m_deckLinkInput->StartStreams();
        return S_OK;
    }

	HRESULT		STDMETHODCALLTYPE VideoInputFrameArrived (/* in */ IDeckLinkVideoInputFrame* videoFrame, /* in */ IDeckLinkAudioInputPacket* audioPacket)
    {

		if (videoFrame->GetFlags() & bmdFrameHasNoInputSource) return S_OK;
		
		fprintf(stderr, "image arrived, %d x %d , %d\n", videoFrame->GetWidth(), videoFrame->GetHeight(), videoFrame->GetRowBytes());
		byte * pdata = NULL;
		videoFrame->GetBytes((void**)&pdata);

		if (m_cb) {
			m_cb((char*)pdata, videoFrame->GetHeight() * videoFrame->GetRowBytes(), m_cb_ctx);
		}

		m_grab_fps.statistics(__FUNCTION__, TRUE);
        return S_OK;
    }
};

CDeckLinkInputDevice::CDeckLinkInputDevice():deckLinkAttributes(NULL), deckLink(NULL), deckLinkInput(NULL), notificationCallback(NULL){

}

void CDeckLinkInputDevice::DestroyObjects() {

	HRESULT						result;
	// Disable the video input interface
	result = ((IDeckLinkInput*)deckLinkInput)->DisableVideoInput();

	// Release the attributes interface
	if (deckLinkAttributes != NULL)
		((IDeckLinkAttributes*)deckLinkAttributes)->Release();

	// Release the video input interface
	if (deckLinkInput != NULL)
		((IDeckLinkInput*)deckLinkInput)->Release();

	// Release the Decklink object
	if (deckLink != NULL)
		((IDeckLink*)deckLink)->Release();

	// Release the DeckLink iterator
	if (--counter == 0 && deckLinkIterator != NULL)
		((IDeckLinkIterator*)deckLinkIterator)->Release();

	// Release the notification callback object
	if (notificationCallback)
		delete notificationCallback;
}

BOOL CDeckLinkInputDevice::CreateObjects(int k) {
	//IDeckLinkIterator*			deckLinkIterator = NULL;
	//IDeckLinkAttributes*        deckLinkAttributes = NULL;
	//IDeckLink*					deckLink = NULL;
	//IDeckLinkInput*             deckLinkInput = NULL;
	//NotificationCallback*       notificationCallback = NULL;

	HRESULT						result;
	BOOL                        supported;
	INT8_UNSIGNED               returnCode = 1;

	Initialize();

	// Create an IDeckLinkIterator object to enumerate all DeckLink cards in the system
	if (NULL == deckLinkIterator) {
		if (GetDeckLinkIterator((IDeckLinkIterator**)(&deckLinkIterator)) != S_OK)
		{
			fprintf(stderr, "A DeckLink iterator could not be created.  The DeckLink drivers may not be installed.\n");
			goto bail;
		}
		counter++;
	}
	else {
		counter++;
	}

	// Obtain every DeckLink device
	for (int i = 0; i < MAX_DEVICES_COUNT; ++i) {
		// Obtain the first DeckLink device
		result = (((IDeckLinkIterator*)deckLinkIterator)->Next((IDeckLink**)(&deckLink)));
	
		if (result != S_OK)	{
			fprintf(stderr, "Could not find DeckLink device - result = %08x\n", result);
			goto bail;
		}
		else {
			if (i == k) {
				break;
			}
			else {
				((IDeckLink*)deckLink)->Release();
			}
		}
	}

	// Obtain the Attributes interface for the DeckLink device
	result = ((IDeckLink*)deckLink)->QueryInterface(IID_IDeckLinkAttributes, (void**)&deckLinkAttributes);
	if (result != S_OK)
	{
		fprintf(stderr, "Could not obtain the IDeckLinkAttributes interface - result = %08x\n", result);
		goto bail;
	}

	// Determine whether the DeckLink device supports input format detection
	result = ((IDeckLinkAttributes*)deckLinkAttributes)->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &supported);
	if ((result != S_OK) || (supported == false))
	{
		fprintf(stderr, "Device does not support automatic mode detection\n");
		goto bail;
	}

	// Obtain the input interface for the DeckLink device
	result = ((IDeckLink*)deckLink)->QueryInterface(IID_IDeckLinkInput, (void**)&deckLinkInput);
	if (result != S_OK)
	{
		fprintf(stderr, "Could not obtain the IDeckLinkInput interface - result = %08x\n", result);
		goto bail;
	}

	// Create an instance of notification callback
	notificationCallback = new NotificationCallback((IDeckLinkInput*)deckLinkInput);
	if (notificationCallback == NULL)
	{
		fprintf(stderr, "Could not create notification callback object\n");
		goto bail;
	}

	// Set the callback object to the DeckLink device's input interface
	result = ((IDeckLinkInput*)deckLinkInput)->SetCallback((NotificationCallback*)notificationCallback);
	if (result != S_OK)
	{
		fprintf(stderr, "Could not set callback - result = %08x\n", result);
		goto bail;
	}

	// Enable video input with a default video mode and the automatic format detection feature enabled
	result = ((IDeckLinkInput*)deckLinkInput)->EnableVideoInput(bmdModeNTSC, bmdFormat10BitYUV, bmdVideoInputEnableFormatDetection);
	if (result != S_OK)
	{
		fprintf(stderr, "Could not enable video input - result = %08x\n", result);
		goto bail;
	}

	return TRUE;

bail:
	DestroyObjects();
	return FALSE;
}

void CDeckLinkInputDevice::setSinkDataCallback(SinkDataCallback cb, void* ctx) {
	((NotificationCallback*)notificationCallback)->m_cb = cb;
	((NotificationCallback*)notificationCallback)->m_cb_ctx = ctx;
}

void CDeckLinkInputDevice::setVideoInputFormatChangedCallback(PixelFormatChangedCallback cb, void* ctx) {
	((NotificationCallback*)notificationCallback)->m_pixle_format_changed_cb = cb;
	((NotificationCallback*)notificationCallback)->m_pixle_format_changed_cb_ctx = ctx;
}

BOOL CDeckLinkInputDevice::start_capture() {
	HRESULT						result;
	// Start capture
	result = ((IDeckLinkInput*)deckLinkInput)->StartStreams();
	if (result != S_OK)
	{
		fprintf(stderr, "Could not start capture - result = %08x\n", result);
		return FALSE;
	}
	return TRUE;
}

BOOL CDeckLinkInputDevice::stop_capture() {
	HRESULT						result;
	// Stop capture
	result = ((IDeckLinkInput*)deckLinkInput)->StopStreams();
	if (result != S_OK)
	{
		fprintf(stderr, "Could not stop capture - result = %08x\n", result);
		return FALSE;
	}
	return TRUE;
}

double CDeckLinkInputDevice::get_fps() {
	return ((NotificationCallback*)notificationCallback)->m_grab_fps.GetFPS();
}

int32_t cb_has_data(char* buffer, int32_t len, void* ctx) {
	FILE* fp = (FILE*)ctx;
	if (fp) {
		fwrite(buffer, len, 1, fp);
	}
	return len;
}

#include "signal.h"
bool g_running_flag = true;
void sig_cb(int sig)
{
	if (sig == SIGINT) {
		fprintf(stdout, "%s\n", __FUNCTION__);
		g_running_flag = false;
	}
}

int main(int argc, char** argv) {
	signal(SIGINT, sig_cb);

	int index = 0;
	if (argc > 1) {
		index = atoi(argv[1]);
	}


	FILE* fp = NULL;
	if (!fp) {
		fopen("1.yuv", "wb");
		if (!fp) {
			fprintf(stderr, "%s fopen failed!\n", __FUNCTION__);
		}
	}
	CDeckLinkInputDevice d;
	d.CreateObjects( index );
	d.setSinkDataCallback(cb_has_data, fp);
	d.start_capture();

	while (g_running_flag) {
		::Sleep(2);
	}

	d.stop_capture();
	d.DestroyObjects();
	fclose(fp);
	return 0;
}